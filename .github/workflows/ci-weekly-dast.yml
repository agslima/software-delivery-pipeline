name: DAST Scan

on:
  schedule:
    - cron: "0 4 * * 0" # Sundays 04:00 UTC
  workflow_dispatch: {}

concurrency:
  group: dast-weekly-${{ github.ref }}
  cancel-in-progress: true

jobs:
  dast:
    name: OWASP ZAP DAST (SPA + API, Auth, Gate, SARIF)
    runs-on: ubuntu-latest

    permissions:
      contents: read
      issues: write
      security-events: write

    env:
      ZAP_IMG: ghcr.io/zaproxy/zaproxy@sha256:8e79e827afb9e8bdba390c829eb3062062cdb407570559e2ddebd49130c00a59
      ZAP_FRONTEND_URL: http://frontend:8080
      ZAP_BACKEND_URL: http://backend:8080
      RUNNER_FRONTEND_URL: http://127.0.0.1:4173
      RUNNER_BACKEND_URL: http://127.0.0.1:8080
      HEALTH_TIMEOUT: "180"

      COMPOSE_PROJECT_NAME: dast-${{ github.run_id }}-${{ github.run_attempt }}
      # COMPOSE_NETWORK: ""

      ZAP_CONTEXT_FILE: ${{ github.workspace }}/.zap/context.context
      ZAP_RULES_FILE: ${{ github.workspace }}/.zap/rules.tsv
      MEDIUM_BLOCK_PATTERNS_FILE: ${{ github.workspace }}/.zap/medium-block-patterns.txt

      ZAP_SCOPE_INCLUDE: '^http://(frontend|backend):8080/.*'
      ZAP_SCOPE_EXCLUDE: '.*\.(css|js|map|png|jpg|jpeg|gif|svg|ico|woff|woff2)$'

      ZAP_SPIDER_MINS: "8"
      ZAP_STARTUP_TIMEOUT_MINS: "5"
      ZAP_PASSIVE_WAIT_SECS: "10"

      BLOCK_HIGH: "1"
      BLOCK_MEDIUM_CATEGORIES: "1"
      BLOCK_MEDIUM_PLUGINIDS: ""

      ZAP_LOGIN_EMAIL: ${{ vars.ZAP_LOGIN_EMAIL }}
      ZAP_LOGIN_PASSWORD: ${{ secrets.ZAP_LOGIN_PASSWORD }}
      DEBUG_DAST: "0"

      AUTH_COVERAGE_REGEX: '/api/v2/'

    steps:
      - uses: actions/checkout@de0fac2e4500dabe0009e67214ff5f5447ce83dd

      - name: Set Variables + Compose Secrets (file-based)
        working-directory: app
        run: |
          set -euo pipefail

          SECRETS_PATH="${RUNNER_TEMP}/compose-secrets"
          echo "SECRETS_PATH=${SECRETS_PATH}" >> "$GITHUB_ENV"

          ENV_FILE=".env"
          rm -f "$ENV_FILE"
          rm -rf "$SECRETS_PATH"
          mkdir -p "$SECRETS_PATH"

          ADMIN_USER_VALUE="${{ vars.ADMIN_USER }}"
          DB_USER_VALUE="${{ vars.DB_USER }}"
          DB_NAME_VALUE="${{ vars.DB_NAME }}"
          ADMIN_PASS_VALUE="${{ secrets.ADMIN_PASS }}"
          DB_PASS_VALUE="${{ secrets.DB_PASS }}"
          JWT_SECRET_VALUE="${{ secrets.JWT_SECRET }}"
          DATA_ENCRYPTION_KEY_VALUE="${{ secrets.DATA_ENCRYPTION_KEY }}"

          [ -n "$ADMIN_USER_VALUE" ] || ADMIN_USER_VALUE="admin"
          [ -n "$DB_USER_VALUE" ] || DB_USER_VALUE="postgres"
          [ -n "$DB_NAME_VALUE" ] || DB_NAME_VALUE="prescriptions_db"
          [ -n "$ADMIN_PASS_VALUE" ] || ADMIN_PASS_VALUE="$(openssl rand -hex 16)"
          [ -n "$DB_PASS_VALUE" ] || DB_PASS_VALUE="$(openssl rand -hex 16)"
          [ -n "$JWT_SECRET_VALUE" ] || JWT_SECRET_VALUE="$(openssl rand -hex 32)"
          [ -n "$DATA_ENCRYPTION_KEY_VALUE" ] || DATA_ENCRYPTION_KEY_VALUE="$(openssl rand -hex 32)"

          echo "::add-mask::${ADMIN_PASS_VALUE}"
          echo "::add-mask::${DB_PASS_VALUE}"
          echo "::add-mask::${JWT_SECRET_VALUE}"
          echo "::add-mask::${DATA_ENCRYPTION_KEY_VALUE}"

          {
            echo "ADMIN_USER=${ADMIN_USER_VALUE}"
            echo "ADMIN_PASS=${ADMIN_PASS_VALUE}"
            echo "DB_USER=${DB_USER_VALUE}"
            echo "DB_NAME=${DB_NAME_VALUE}"
            echo "DB_PASS=${DB_PASS_VALUE}"
            echo "JWT_SECRET=${JWT_SECRET_VALUE}"
            echo "DATA_ENCRYPTION_KEY=${DATA_ENCRYPTION_KEY_VALUE}"
            echo "COMPOSE_PROJECT_NAME=${{ env.COMPOSE_PROJECT_NAME }}"
            echo "SECRETS_PATH=${SECRETS_PATH}"
            echo "SEED_ADMIN_EMAIL=${{ vars.ZAP_LOGIN_EMAIL }}"
            echo "SEED_DEFAULT_PASSWORD=${{ secrets.ZAP_LOGIN_PASSWORD }}"
          } >> "$ENV_FILE"
          chmod 600 "$ENV_FILE"

          printf "%s" "$JWT_SECRET_VALUE"  > "${SECRETS_PATH}/jwt_secret.txt"
          printf "%s" "$ADMIN_PASS_VALUE"  > "${SECRETS_PATH}/admin_pass.txt"
          printf "%s" "$DB_PASS_VALUE"     > "${SECRETS_PATH}/db_pass.txt"
          printf "%s" "$DATA_ENCRYPTION_KEY_VALUE" > "${SECRETS_PATH}/data_encryption_key.txt"
          chmod 600 "${SECRETS_PATH}"/*.txt

      - name: Start Ephemeral Environment
        working-directory: app
        run: |
          set -euo pipefail

          docker compose up -d --build
          echo "COMPOSE_NETWORK=${{ env.COMPOSE_PROJECT_NAME }}_app_network" >> "$GITHUB_ENV"

          DB_PASS_VALUE="$(cat "$SECRETS_PATH/db_pass.txt")"
          echo "::add-mask::${DB_PASS_VALUE}"
          docker compose exec -T -e DB_PASS="$DB_PASS_VALUE" backend node ./node_modules/knex/bin/cli.js migrate:latest --knexfile src/config/knexfile.js
          docker compose exec -T -e DB_PASS="$DB_PASS_VALUE" backend node ./node_modules/knex/bin/cli.js seed:run --knexfile src/config/knexfile.js

          timeout "${{ env.HEALTH_TIMEOUT }}s" bash -c 'until curl -fsS "${{ env.RUNNER_BACKEND_URL }}/health" >/dev/null; do sleep 5; done'
          timeout "${{ env.HEALTH_TIMEOUT }}s" bash -c 'until curl -fsS "${{ env.RUNNER_FRONTEND_URL }}/health" >/dev/null; do sleep 5; done'
          timeout "${{ env.HEALTH_TIMEOUT }}s" bash -c 'until curl -fsS "${{ env.RUNNER_FRONTEND_URL }}/" | head -n 3 | grep -qi "<!doctype"; do sleep 5; done' || true

          docker compose ps

      - name: Prepare ZAP Output
        working-directory: app
        run: |
          set -euo pipefail
          mkdir -p zap-out
          chmod 777 zap-out

          test -f "${{ env.ZAP_CONTEXT_FILE }}" || (echo "::error::Missing context file ${{ env.ZAP_CONTEXT_FILE }}"; exit 1)
          test -f "${{ env.ZAP_RULES_FILE }}" || (echo "::error::Missing rules file ${{ env.ZAP_RULES_FILE }}"; exit 1)
          test -f "${{ env.MEDIUM_BLOCK_PATTERNS_FILE }}" || (echo "::error::Missing medium block patterns file ${{ env.MEDIUM_BLOCK_PATTERNS_FILE }}"; exit 1)

      - name: Auth Bootstrap (mint JWT) + Verify
        working-directory: app
        run: |
          set -euo pipefail

          RUNNER_BACKEND_BASE="${RUNNER_BACKEND_URL:-}"
          if [ -z "${RUNNER_BACKEND_BASE}" ]; then
            echo "::error::RUNNER_BACKEND_URL is not set."
            exit 1
          fi
          RUNNER_BACKEND_BASE="${RUNNER_BACKEND_BASE%/}"
          LOGIN_URL="${RUNNER_BACKEND_BASE}/api/v2/auth/login"
          AUTH_VERIFY_URL="${RUNNER_BACKEND_BASE}/api/v2/auth/mfa/status"
          echo "Using auth endpoints: LOGIN_URL=${LOGIN_URL} AUTH_VERIFY_URL=${AUTH_VERIFY_URL}"
          LOGIN_EMAIL="${{ env.ZAP_LOGIN_EMAIL }}"
          LOGIN_PASSWORD="${{ env.ZAP_LOGIN_PASSWORD }}"

          if [ -z "$LOGIN_EMAIL" ] || [ -z "$LOGIN_PASSWORD" ]; then
            echo "::error::Missing vars.ZAP_LOGIN_EMAIL and/or secrets.ZAP_LOGIN_PASSWORD for DAST auth bootstrap."
            exit 1
          fi

          echo "::add-mask::${LOGIN_EMAIL}"
          echo "::add-mask::${LOGIN_PASSWORD}"

          LOGIN_PAYLOAD="$(jq -cn --arg email "$LOGIN_EMAIL" --arg password "$LOGIN_PASSWORD" '{email:$email,password:$password}')"
          AUTH_HTTP_CODE=""
          RESP=""
          for attempt in 1 2 3 4 5; do
            RESP="$(curl -sS -X POST "${LOGIN_URL}" -H "Content-Type: application/json" --data "$LOGIN_PAYLOAD" -w $'\n%{http_code}')"
            AUTH_HTTP_CODE="$(printf '%s' "$RESP" | tail -n 1)"
            RESP="$(printf '%s' "$RESP" | sed '$d')"

            if [ "$AUTH_HTTP_CODE" = "200" ]; then
              break
            fi

            if [ "$AUTH_HTTP_CODE" -ge 500 ] 2>/dev/null; then
              echo "::warning::Auth bootstrap returned HTTP ${AUTH_HTTP_CODE} (attempt ${attempt}/5). Retrying..."
              sleep 3
              continue
            fi

            break
          done

          if [ "$AUTH_HTTP_CODE" != "200" ]; then
            echo "::error::Auth bootstrap failed with HTTP ${AUTH_HTTP_CODE}."
            echo "$RESP" | jq -c '{error, message, code, details}' 2>/dev/null || true
            docker compose logs --no-color --tail=200 backend || true
            exit 1
          fi

          MFA_REQUIRED="$(echo "$RESP" | jq -r '.mfaRequired // false' || true)"
          if [ "$MFA_REQUIRED" = "true" ]; then
            echo "::error::MFA is enabled for this user. Use a non-MFA account for DAST."
            exit 1
          fi

          TOKEN="$(echo "$RESP" | jq -r '.accessToken // .token // empty' || true)"
          if [ -z "$TOKEN" ]; then
            echo "::error::Could not acquire JWT. Response redacted; check backend logs."
            echo "$RESP" | jq -c '{mfaRequired, error, message}' || true
            docker compose logs --no-color --tail=200 backend || true
            exit 1
          fi

          echo "::add-mask::${TOKEN}"
          AUTH_HEADER="Authorization: Bearer ${TOKEN}"
          echo "::add-mask::${AUTH_HEADER}"

          echo "ZAP_AUTH_TOKEN=${TOKEN}" >> "$GITHUB_ENV"
          echo "DAST_AUTH_ASSERTION_PASSED=0" >> "$GITHUB_ENV"

          if [ -n "${AUTH_VERIFY_URL}" ]; then
            curl -fsS -o /dev/null -H "Authorization: Bearer ${TOKEN}" "${AUTH_VERIFY_URL}"
            echo "DAST_AUTH_ASSERTION_PASSED=1" >> "$GITHUB_ENV"
            echo "âœ… Auth verification passed"
          else
            echo "::warning::AUTH_VERIFY_URL not set; consider adding a protected endpoint."
          fi

          if [ "${{ env.DEBUG_DAST }}" = "1" ]; then
            printf "%s\n" "Authorization: Bearer ${TOKEN}" > zap-out/zap-auth-header.txt
            chmod 600 zap-out/zap-auth-header.txt
          fi

      - name: OWASP ZAP Full Scan (Frontend, Auth, Context, Rules)
        working-directory: app
        run: |
          set -euo pipefail

          VOL_PATH="$(pwd)/zap-out"
          TARGET="${{ env.ZAP_FRONTEND_URL }}"
          AUTH_VALUE="Bearer ${ZAP_AUTH_TOKEN}"

          set +e
          docker run --rm \
            --network "${COMPOSE_NETWORK}" \
            -v "$VOL_PATH:/zap/wrk/:rw" \
            -v "${{ env.ZAP_CONTEXT_FILE }}:/zap/wrk/context.context:ro" \
            -v "${{ env.ZAP_RULES_FILE }}:/zap/wrk/rules.tsv:ro" \
            "${{ env.ZAP_IMG }}" zap-full-scan.py \
            -t "$TARGET" \
            -n /zap/wrk/context.context \
            -c /zap/wrk/rules.tsv \
            -m "${{ env.ZAP_SPIDER_MINS }}" \
            -T "${{ env.ZAP_STARTUP_TIMEOUT_MINS }}" \
            -D "${{ env.ZAP_PASSIVE_WAIT_SECS }}" \
            -j \
            -r zap-frontend.html \
            -J zap-frontend.json \
            -I \
            -z "-config replacer.full_list(0).description=authheader" \
            -z "-config replacer.full_list(0).enabled=true" \
            -z "-config replacer.full_list(0).matchtype=REQ_HEADER" \
            -z "-config replacer.full_list(0).matchstr=Authorization" \
            -z "-config replacer.full_list(0).regex=false" \
            -z "-config replacer.full_list(0).replacement=${AUTH_VALUE}"
          ZAP_EXIT=$?
          set -e

          echo "ZAP_EXIT_FRONTEND=$ZAP_EXIT" >> "$GITHUB_ENV"
          test -s "zap-out/zap-frontend.json" || (echo "::error::ZAP FE json missing/empty"; exit 1)
          jq -e 'type=="object"' "zap-out/zap-frontend.json" >/dev/null

      - name: Assert authenticated coverage (Frontend)
        working-directory: app
        run: |
          set -euo pipefail
          FE="zap-out/zap-frontend.json"
          # Coverage assertion (robust): count matching URLs across multiple possible instance shapes
          # Note: This still proves "coverage reached URLs", not HTTP 200. Keep AUTH_VERIFY_URL as the auth truth.
          MATCHES="$(jq --arg re "${{ env.AUTH_COVERAGE_REGEX }}" '
            def uris:
              [ .site[]?
                | .alerts[]?
                | (.instances? // [])
                | .[]?
                | (.uri? // .url? // empty)
              ];
            uris | map(select(. != "" and test($re))) | length
          ' "$FE")"
          if [ "$MATCHES" -eq 0 ]; then
            echo "::warning::No authenticated coverage match found in frontend scan for regex=${{ env.AUTH_COVERAGE_REGEX }}"
            echo "DAST_AUTH_COVERAGE_FRONTEND=0" >> "$GITHUB_ENV"
          else
            echo "DAST_AUTH_COVERAGE_FRONTEND=1" >> "$GITHUB_ENV"
          fi

      - name: Auth Refresh (re-mint JWT) before Backend scan
        working-directory: app
        run: |
          set -euo pipefail

          RUNNER_BACKEND_BASE="${RUNNER_BACKEND_URL:-}"
          if [ -z "${RUNNER_BACKEND_BASE}" ]; then
            echo "::error::RUNNER_BACKEND_URL is not set."
            exit 1
          fi
          RUNNER_BACKEND_BASE="${RUNNER_BACKEND_BASE%/}"
          LOGIN_URL="${RUNNER_BACKEND_BASE}/api/v2/auth/login"
          AUTH_VERIFY_URL="${RUNNER_BACKEND_BASE}/api/v2/auth/mfa/status"
          echo "Using auth endpoints: LOGIN_URL=${LOGIN_URL} AUTH_VERIFY_URL=${AUTH_VERIFY_URL}"
          LOGIN_EMAIL="${{ env.ZAP_LOGIN_EMAIL }}"
          LOGIN_PASSWORD="${{ env.ZAP_LOGIN_PASSWORD }}"

          if [ -z "$LOGIN_EMAIL" ] || [ -z "$LOGIN_PASSWORD" ]; then
            echo "::error::Missing vars.ZAP_LOGIN_EMAIL and/or secrets.ZAP_LOGIN_PASSWORD for DAST auth refresh."
            exit 1
          fi

          echo "::add-mask::${LOGIN_EMAIL}"
          echo "::add-mask::${LOGIN_PASSWORD}"

          LOGIN_PAYLOAD="$(jq -cn --arg email "$LOGIN_EMAIL" --arg password "$LOGIN_PASSWORD" '{email:$email,password:$password}')"
          AUTH_HTTP_CODE=""
          RESP=""
          for attempt in 1 2 3 4 5; do
            RESP="$(curl -sS -X POST "${LOGIN_URL}" \
              -H "Content-Type: application/json" \
              --data "$LOGIN_PAYLOAD" \
              -w $'\n%{http_code}')"
            AUTH_HTTP_CODE="$(printf '%s' "$RESP" | tail -n 1)"
            RESP="$(printf '%s' "$RESP" | sed '$d')"

            if [ "$AUTH_HTTP_CODE" = "200" ]; then
              break
            fi

            if [ "$AUTH_HTTP_CODE" -ge 500 ] 2>/dev/null; then
              echo "::warning::Auth refresh returned HTTP ${AUTH_HTTP_CODE} (attempt ${attempt}/5). Retrying..."
              sleep 3
              continue
            fi

            break
          done

          if [ "$AUTH_HTTP_CODE" != "200" ]; then
            echo "::error::Auth refresh failed with HTTP ${AUTH_HTTP_CODE}."
            echo "$RESP" | jq -c '{error, message, code, details}' 2>/dev/null || true
            docker compose logs --no-color --tail=200 backend || true
            exit 1
          fi

          MFA_REQUIRED="$(echo "$RESP" | jq -r '.mfaRequired // false' || true)"
          if [ "$MFA_REQUIRED" = "true" ]; then
            echo "::error::MFA is enabled for this user. Use a non-MFA account for DAST."
            exit 1
          fi

          TOKEN="$(echo "$RESP" | jq -r '.accessToken // .token // empty' || true)"
          if [ -z "$TOKEN" ]; then
            echo "::error::Could not acquire refreshed JWT. Response redacted; check backend logs."
            echo "$RESP" | jq -c '{mfaRequired, error, message}' || true
            docker compose logs --no-color --tail=200 backend || true
            exit 1
          fi

          echo "::add-mask::${TOKEN}"
          echo "ZAP_AUTH_TOKEN=${TOKEN}" >> "$GITHUB_ENV"

          if [ -n "${AUTH_VERIFY_URL}" ]; then
            curl -fsS -o /dev/null -H "Authorization: Bearer ${TOKEN}" "${AUTH_VERIFY_URL}"
            echo "âœ… Auth refresh verification passed"
          fi

      - name: Prepare OpenAPI (rewrite servers URL)
        working-directory: app
        run: |
          set -euo pipefail

          SRC="server/src/docs/openapi.yaml"
          OUT="zap-out/openapi.yaml"
          test -f "$SRC" || (echo "::error::Missing OpenAPI spec at $SRC"; exit 1)

          SRC="$SRC" OUT="$OUT" ZAP_BACKEND_URL="${{ env.ZAP_BACKEND_URL }}" python3 - <<'PY'
          import os, re
          src = os.environ["SRC"]
          out = os.environ["OUT"]
          backend = os.environ["ZAP_BACKEND_URL"]
          with open(src, "r", encoding="utf-8") as f:
            text = f.read()
          new_block = f"servers:\n  - url: {backend}\n"
          pattern = re.compile(r"^servers:\n(?:^[ \t]+-.*\n)+", re.M)
          if pattern.search(text):
            text = pattern.sub(new_block, text, count=1)
          else:
            text = new_block + "\n" + text
          with open(out, "w", encoding="utf-8") as f:
            f.write(text)
          if not text.strip():
            raise SystemExit("rewritten openapi.yaml is empty")
          print(f"Wrote {out}")
          PY

          python3 -c 'import pathlib; p=pathlib.Path("zap-out/openapi.yaml"); assert p.exists() and p.stat().st_size>0'
          ENDPOINT_COUNT="$(grep -Ec '^\s{2}/' zap-out/openapi.yaml || true)"
          if [ "$ENDPOINT_COUNT" -eq 0 ]; then
            echo "::error::OpenAPI rewrite produced zero endpoints"
            exit 1
          fi

          echo "OPENAPI_FOUND=1" >> "$GITHUB_ENV"
          echo "OPENAPI_FILE=zap-out/openapi.yaml" >> "$GITHUB_ENV"

      - name: OWASP ZAP API Scan (Backend, OpenAPI, Auth) â€” preferred
        if: env.OPENAPI_FOUND == '1'
        working-directory: app
        run: |
          set -euo pipefail

          VOL_PATH="$(pwd)/zap-out"
          AUTH_VALUE="Bearer ${ZAP_AUTH_TOKEN}"
          OPENAPI_FILE="${{ env.OPENAPI_FILE }}"

          set +e
          docker run --rm \
            --network "${COMPOSE_NETWORK}" \
            -v "$VOL_PATH:/zap/wrk/:rw" \
            -v "${{ env.ZAP_RULES_FILE }}:/zap/wrk/rules.tsv:ro" \
            "${{ env.ZAP_IMG }}" zap-api-scan.py \
            -t /zap/wrk/openapi.yaml \
            -f openapi \
            -r zap-backend.html \
            -J zap-backend.json \
            -c /zap/wrk/rules.tsv \
            -I \
            -z "-config replacer.full_list(0).description=authheader" \
            -z "-config replacer.full_list(0).enabled=true" \
            -z "-config replacer.full_list(0).matchtype=REQ_HEADER" \
            -z "-config replacer.full_list(0).matchstr=Authorization" \
            -z "-config replacer.full_list(0).regex=false" \
            -z "-config replacer.full_list(0).replacement=${AUTH_VALUE}"
          ZAP_EXIT=$?
          set -e

          echo "ZAP_EXIT_BACKEND=$ZAP_EXIT" >> "$GITHUB_ENV"
          test -s "zap-out/zap-backend.json" || (echo "::error::ZAP BE json missing/empty"; exit 1)
          jq -e 'type=="object"' "zap-out/zap-backend.json" >/dev/null

      - name: Assert authenticated coverage (Backend)
        working-directory: app
        run: |
          set -euo pipefail
          BE="zap-out/zap-backend.json"
          MATCHES="$(jq --arg re "${{ env.AUTH_COVERAGE_REGEX }}" '
            def uris:
              [ .site[]?
                | .alerts[]?
                | (.instances? // [])
                | .[]?
                | (.uri? // .url? // empty)
              ];
            uris | map(select(. != "" and test($re))) | length
          ' "$BE")"
          if [ "$MATCHES" -eq 0 ]; then
            echo "::warning::No authenticated coverage match found in backend scan for regex=${{ env.AUTH_COVERAGE_REGEX }}"
            echo "DAST_AUTH_COVERAGE_BACKEND=0" >> "$GITHUB_ENV"
          else
            echo "DAST_AUTH_COVERAGE_BACKEND=1" >> "$GITHUB_ENV"
          fi

      - name: Gate + Summary (Risk + Confidence)
        working-directory: app
        run: |
          set -euo pipefail

          FE="zap-out/zap-frontend.json"
          BE="zap-out/zap-backend.json"
          PATTERN="$(
            awk '
              BEGIN { ORS=""; first=1 }
              {
                line=$0
                sub(/^[ \t\r\n]+/, "", line)
                sub(/[ \t\r\n]+$/, "", line)
                if (line == "" || line ~ /^#/) next
                if (!first) printf "|"
                printf "%s", line
                first=0
              }
            ' "${{ env.MEDIUM_BLOCK_PATTERNS_FILE }}"
          )"
          if [ -z "${PATTERN}" ]; then
            echo "::error::Medium block patterns file produced an empty pattern. Check ${MEDIUM_BLOCK_PATTERNS_FILE}."
            exit 1
          fi
          echo "MEDIUM_BLOCK_PATTERNS=${PATTERN}" >> "$GITHUB_ENV"

          count_alerts () {
            local file="$1"; local risk="$2"; local min_conf="$3"
            jq --arg r "$risk" --arg mc "$min_conf" '
              def confRank(c): if (c|ascii_downcase) == "high" then 3 elif (c|ascii_downcase) == "medium" then 2 elif (c|ascii_downcase) == "low" then 1 else 0 end;
              def minRank(mc): if (mc|ascii_downcase) == "high" then 3 elif (mc|ascii_downcase) == "medium" then 2 elif (mc|ascii_downcase) == "low" then 1 else 0 end;
              [ .site[]? | .alerts[]? | select((.riskcode|tostring) == $r) | select(confRank(.confidence // "") >= minRank($mc)) ] | length
            ' "$file"
          }

          emit_top_findings () {
            local file="$1"; local label="$2"
            echo "### ${label}"
            jq --arg re "$PATTERN" --arg pids "${{ env.BLOCK_MEDIUM_PLUGINIDS }}" '
              def confRank(c):
                if (c|ascii_downcase) == "high" then 3
                elif (c|ascii_downcase) == "medium" then 2
                elif (c|ascii_downcase) == "low" then 1
                else 0 end;
              def pidAllowed(pid):
                if ($pids|length) == 0 then false
                else ($pids|split(",")|map(gsub("\\s+";""))|index(pid)) != null end;
              [ .site[]? | .alerts[]?
                | . as $a
                | ($a.instances // []) as $ins
                | {
                    alert: ($a.alert // "Unknown alert"),
                    riskcode: ($a.riskcode|tostring),
                    confidence: ($a.confidence // ""),
                    pluginid: (($a.pluginid // $a.pluginId // "")|tostring),
                    count: ($ins|length),
                    sampleUrls: (($ins|map(.uri // .url)|map(select(. != null))|.[0:3]))
                  }
                | select(
                    (.riskcode == "3" and confRank(.confidence) >= 2)
                    or
                    (.riskcode == "2" and confRank(.confidence) >= 2 and ((.alert|test($re; "i")) or pidAllowed(.pluginid)))
                  )
              ] | .[] | "- [plugin:\(.pluginid)] \(.alert) (risk=\(.riskcode), confidence=\(.confidence), instances=\(.count)) urls=\(.sampleUrls|join(", "))"' "$file"
          }

          HIGH_FE=$(count_alerts "$FE" "3" "medium")
          HIGH_BE=$(count_alerts "$BE" "3" "medium")
          MED_FE=$(count_alerts "$FE" "2" "low")
          MED_BE=$(count_alerts "$BE" "2" "low")

          MED_BLOCK () {
            local file="$1"
            jq --arg re "$PATTERN" --arg pids "${{ env.BLOCK_MEDIUM_PLUGINIDS }}" '
              def confRank(c): if (c|ascii_downcase) == "high" then 3 elif (c|ascii_downcase) == "medium" then 2 elif (c|ascii_downcase) == "low" then 1 else 0 end;
              def pidAllowed(pid): if ($pids|length) == 0 then false else ($pids|split(",")|map(gsub("\\s+";""))|index(pid)) != null end;
              [ .site[]? | .alerts[]?
                | select((.riskcode|tostring) == "2")
                | select(confRank(.confidence // "") >= 2)
                | select(( (.alert? // "") | test($re; "i") ) or pidAllowed((.pluginid // .pluginId // "")|tostring))
              ] | length
            ' "$file"
          }

          MED_BLOCK_FE=$(MED_BLOCK "$FE")
          MED_BLOCK_BE=$(MED_BLOCK "$BE")
          echo "MED_BLOCK_FE=$MED_BLOCK_FE" >> "$GITHUB_ENV"
          echo "MED_BLOCK_BE=$MED_BLOCK_BE" >> "$GITHUB_ENV"

          SUMMARY="zap-out/summary.md"
          {
            echo "# DAST Weekly Summary"
            echo ""
            echo "## Counts"
            echo "| Target | High (conf>=Medium) | Medium |"
            echo "|---|---:|---:|"
            echo "| Frontend | ${HIGH_FE} | ${MED_FE} |"
            echo "| Backend | ${HIGH_BE} | ${MED_BE} |"
            echo ""
            echo "## Authenticated coverage"
            echo "- Auth verification passed: ${DAST_AUTH_ASSERTION_PASSED:-0}"
            echo "- Frontend authenticated coverage: ${DAST_AUTH_COVERAGE_FRONTEND:-0}"
            echo "- Backend authenticated coverage: ${DAST_AUTH_COVERAGE_BACKEND:-0}"
            echo ""
            echo "## Top Findings (gate-relevant)"
            emit_top_findings "$FE" "Frontend"
            emit_top_findings "$BE" "Backend"
          } > "$SUMMARY"

          if [ "${{ env.BLOCK_HIGH }}" = "1" ] && { [ "$HIGH_FE" -gt 0 ] || [ "$HIGH_BE" -gt 0 ]; }; then
            jq -r '.site[]?.alerts[]? | select((.riskcode|tostring)=="3" and ((.confidence|ascii_downcase)=="high" or (.confidence|ascii_downcase)=="medium")) | "::error::Gate blocker plugin=\((.pluginid // .pluginId // "")|tostring) alert=\(.alert // "") confidence=\(.confidence // "") url=\((((.instances // [])[0].uri) // (((.instances // [])[0].url)) // "n/a"))"' "$FE" "$BE" || true
            echo "::error::â›” DAST Gate Failed: High vulnerabilities (confidence>=Medium) found (FE=$HIGH_FE, BE=$HIGH_BE)"
            exit 1
          fi

          if [ "${{ env.BLOCK_MEDIUM_CATEGORIES }}" = "1" ] && { [ "$MED_BLOCK_FE" -gt 0 ] || [ "$MED_BLOCK_BE" -gt 0 ]; }; then
            echo "::error::â›” DAST Gate Failed: Selected Medium categories (confidence>=Medium) found (FE=$MED_BLOCK_FE, BE=$MED_BLOCK_BE)"
            exit 1
          fi

      - name: Generate SARIF (from ZAP JSON)
        if: always()
        working-directory: app
        run: |
          set -euo pipefail
          python3 - <<'PY'
          import json, os, hashlib, datetime

          def level_from_riskcode(rc: str) -> str:
            rc = str(rc)
            if rc == "3": return "error"
            if rc == "2": return "warning"
            return "note"

          def load_alerts(path: str):
            with open(path, "r", encoding="utf-8") as f:
              data = json.load(f)
            return [a for site in data.get("site", []) or [] for a in (site.get("alerts", []) or [])]

          def collect_urls(alerts):
            urls = []
            for a in alerts:
              instances = a.get("instances") or []
              if not instances:
                uri = a.get("uri") or a.get("url")
                if uri: instances = [{"uri": uri}]
              for inst in instances:
                uri = inst.get("uri") or inst.get("url")
                if uri and uri.startswith(("http://", "https://")): urls.append(uri)
            return urls

          def to_sarif(scan_name: str, json_path: str, out_path: str, url_map: dict):
            alerts = load_alerts(json_path)
            rules = {}
            results = []

            for a in alerts:
              alert = a.get("alert") or a.get("name") or "ZAP Alert"
              pluginid = str(a.get("pluginid") or a.get("pluginId") or a.get("alertRef") or "unknown")
              riskcode = str(a.get("riskcode") or a.get("risk code") or "0")
              confidence = a.get("confidence") or ""
              desc = a.get("desc") or ""
              sol = a.get("solution") or ""
              ref = a.get("reference") or ""

              rid = f"ZAP-{pluginid}"
              if rid not in rules:
                rules[rid] = {
                  "id": rid,
                  "name": alert,
                  "shortDescription": {"text": alert},
                  "fullDescription": {"text": f"{desc}\n\nSolution: {sol}\n\nReference: {ref}".strip()},
                  "helpUri": "https://www.zaproxy.org/docs/alerts/",
                  "properties": {"tags": ["security", "dast", "owasp-zap", f"zap-plugin:{pluginid}"], "confidence": confidence, "pluginid": pluginid},
                }

              instances = a.get("instances") or []
              if not instances:
                uri = a.get("uri") or a.get("url")
                if uri: instances = [{"uri": uri}]

              for inst in instances:
                uri = inst.get("uri") or inst.get("url") or "unknown"
                artifact_uri = uri
                region = None
                if uri.startswith(("http://", "https://")):
                  artifact_uri = "zap-out/targets.txt"
                  if uri in url_map: region = {"startLine": url_map[uri]}
                evidence = inst.get("evidence") or ""
                method = inst.get("method") or ""
                param = inst.get("param") or ""

                fp_primary = hashlib.sha256(f"{rid}|{uri}|{param}|{method}".encode("utf-8")).hexdigest()
                fp_instance = hashlib.sha256(f"{pluginid}|{uri}|{evidence}".encode("utf-8")).hexdigest()

                results.append({
                  "ruleId": rid,
                  "level": level_from_riskcode(riskcode),
                  "message": {"text": f"{alert} (confidence={confidence})"},
                  "locations": [{"physicalLocation": {"artifactLocation": {"uri": artifact_uri}, **({"region": region} if region else {})}}],
                  "partialFingerprints": {"primaryLocationLineHash": fp_primary},
                  "fingerprints": {
                    "zapPrimaryFingerprint": fp_primary,
                    "zapInstanceFingerprint": fp_instance,
                  },
                  "properties": {"confidence": confidence, "riskcode": riskcode, "pluginid": pluginid, "param": param, "method": method, "evidence": evidence, "url": uri, "tags": ["security", "dast", "owasp-zap", f"zap-plugin:{pluginid}"]}
                })

            sarif = {
              "version": "2.1.0",
              "$schema": "https://json.schemastore.org/sarif-2.1.0.json",
              "runs": [{
                "tool": {"driver": {"name": "OWASP ZAP", "informationUri": "https://www.zaproxy.org/", "rules": list(rules.values())}},
                "automationDetails": {"id": scan_name},
                "results": results,
                "invocations": [{"executionSuccessful": True, "startTimeUtc": datetime.datetime.utcnow().isoformat() + "Z"}]
              }]
            }
            with open(out_path, "w", encoding="utf-8") as f:
              json.dump(sarif, f, indent=2)

          os.makedirs("zap-out", exist_ok=True)
          all_alerts = load_alerts("zap-out/zap-frontend.json") + load_alerts("zap-out/zap-backend.json")
          urls = sorted(set(collect_urls(all_alerts)))
          url_map = {}
          with open("zap-out/targets.txt", "w", encoding="utf-8") as f:
            for i, url in enumerate(urls, start=1):
              f.write(url + "\n")
              url_map[url] = i

          to_sarif("frontend", "zap-out/zap-frontend.json", "zap-out/zap-frontend.sarif", url_map)
          to_sarif("backend", "zap-out/zap-backend.json", "zap-out/zap-backend.sarif", url_map)
          PY

      - name: Upload SARIF (Frontend)
        if: always()
        uses: github/codeql-action/upload-sarif@45cbd0c69e560cd9e7cd7f8c32362050c9b7ded2
        with:
          sarif_file: app/zap-out/zap-frontend.sarif
          category: zap-frontend

      - name: Upload SARIF (Backend)
        if: always()
        uses: github/codeql-action/upload-sarif@45cbd0c69e560cd9e7cd7f8c32362050c9b7ded2
        with:
          sarif_file: app/zap-out/zap-backend.sarif
          category: zap-backend

      - name: Upload ZAP Artifacts (folder)
        if: always()
        uses: actions/upload-artifact@b7c566a772e6b6bfb58ed0dc250532a479d7789f
        with:
          name: zap-out
          path: app/zap-out/
          retention-days: 30

      - name: Debug - Container Logs
        if: failure()
        working-directory: app
        run: |
          docker compose ps || true
          docker compose logs --no-color || true

      - name: Init DAST defaults (avoid empty envs)
        run: |
          echo "DAST_AUTH_ASSERTION_PASSED=0" >> "$GITHUB_ENV"
          echo "DAST_AUTH_COVERAGE_FRONTEND=0" >> "$GITHUB_ENV"
          echo "DAST_AUTH_COVERAGE_BACKEND=0" >> "$GITHUB_ENV"
          
      - name: Create Issue on Failure
        if: failure()
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          set -euo pipefail
          TODAY="$(date -u +%Y-%m-%d)"
          KEY="DAST_FAIL_${TODAY}_${{ github.workflow }}"
          RUN_URL="${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }}"
          SUMMARY_EXCERPT="$(head -n 25 app/zap-out/summary.md 2>/dev/null || echo 'summary.md unavailable')"

          TITLE="ðŸš¨ DAST Weekly Failed (${TODAY})"
          BODY=$(cat <<EOF
          **Key:** ${KEY}
          **Workflow:** ${{ github.workflow }}
          **Date (UTC):** ${TODAY}
          **Run:** ${RUN_URL}
          **Commit SHA:** ${{ github.sha }}
          **Actor:** ${{ github.actor }}

          ## Auth assertions
          - Auth verify URL passed: ${{ env.DAST_AUTH_ASSERTION_PASSED }}
          - FE authenticated coverage: ${{ env.DAST_AUTH_COVERAGE_FRONTEND }}
          - BE authenticated coverage: ${{ env.DAST_AUTH_COVERAGE_BACKEND }}

          ## Summary excerpt
          \`\`\`
          ${SUMMARY_EXCERPT}
          \`\`\`
          EOF
          )

          if gh issue list --limit 100 --search "${KEY}" --json body | jq -e --arg k "${KEY}" '.[] | select(.body | contains($k))' >/dev/null; then
            exit 0
          fi

          gh issue create --title "$TITLE" --body "$BODY" --label "security" --label "dast" --label "automated"

      - name: Cleanup Secrets + Env
        if: always()
        working-directory: app
        run: |
          set -euo pipefail
          rm -f .env
          if [ -n "${SECRETS_PATH:-}" ] && [ -d "${SECRETS_PATH:-}" ]; then
            rm -rf "${SECRETS_PATH}"
          fi
          rm -f zap-out/zap-auth-header.txt || true

      - name: Teardown
        if: always()
        working-directory: app
        run: docker compose down -v --remove-orphans
